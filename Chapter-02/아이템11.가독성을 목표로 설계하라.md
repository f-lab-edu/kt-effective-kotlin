## (아이템 11) 가독성을 목표로 설계하라

로버트 마틴 (클린코드) : “개발자가 코드를 작성하는데는 1분 걸리지만, 이를 읽는데는 10분이 걸린다”

- 코드를 작성하다가 오류가 생기면, 작성하는 시간보다 더 오랜 시간을 코드를 보게된다.
- 한 줄을 고치기 위해 몇 주 동안 코드를 살펴보는 경우도 있다.
- 그래서 프로그래밍은 쓰기보다 읽기가 중요하다.

### 인식 부하 감소

**가독성은 사람마다 다르게 느낄 수 있다.** 

- 가독성은 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미한다.
- 이해하기 쉬운지는 읽는 사람이 얼마나 많은 관용구(구조, 함수, 패턴)에 익숙한지에 따라 달라진다.

```kotlin
// 구현 A
if (person != null && person.isAdult) {
  view.showPerson(person)
} else {
  view.showError()
}

// 구현 B
person?.takeIf { it.isAdult }
  ?.let(view::showPerson)
  ?: view.showError()
```

- 코틀린 초보자는 구현 A가 더 이해하기 쉽다.
    
    일반적인 관용구(if/ese, &&, 메서드 호출)을 사용하기 때문이다.
    
- 경험이 많은 코틀린 개발자는 구현 B도 쉽게 읽을 수 있다.
    
    코틀린에서 사용되는 관용구 (안전 호출 ?., takeIf, let, Elvis 연산자, 제한된 함수 레퍼런스 view::showPerson) 를 사용하기 때문이다.
    
- 그러나 코틀린은 대부분의 개발자에게 첫번째 언어가 아니다.
    
    신입개발자는 물론이고, 숙련된 코틀린 개발자에게도 구현 A가 이해하기 쉽다. 
    
  
<br> 

**구현 A가 확장하기도 더 쉽다.**

```kotlin
// 구현 A
if (person != null && person.isAdult) {
  view.showPerson(person)
  view.hideProgressWithSuccess()
} else {
  view.showError()
  view.hideProgress()
}

// 구현 B
person?.takeIf { it.isAdult }
  ?.let {
    view.showPerson(it)
    view.hideProgressWithSuccess()
  } ?: run {
    view.showError()
    view.hideProgress()
  }
```

- 구현 A는 확장을 위해 if/else 블록에 코드를 추가하면 된다.
- 구현 B를 확장하기 위해서는 함수를 추가로 사용해야 한다.
  
<br> 

**디버깅도 구현 A가 더 쉽다.**

- 디버깅 도구도 이러한 기본 구조를 더 잘 분석해주기 때문이다.


 <br> 

**구현 A와 구현 B의 결과가 다르다.**

- 구현 A는 showPerson 또는 show Error 를 호출한다.
- 구현 B에서 let은 람다식의 결과를 리턴한다. 
즉 showPerson 이 null을 리턴하면 showError 도 호출된다.
- **⇒ 익숙하지 않은 구조(구현 B)의 결과를 예측하기 어렵다.**
  
<br> 

**결론**

- 인지 부하를 줄이는 방향으로 코드를 작성해라.
- 짧은 코드보다 익숙한 코드를 더 빠르게 읽을 수 있다.

    
<br> 


### 극단적이 되지 않기

앞에서 let 으로 인해 예상치 못한 결과가 나올 수 있다고 했다. 

- 그렇다고 let 을 쓰면 안된다고 이해할 필요 없다.
- ⇒ 극단적이 되지 말자
e.g.) let은 좋은 코드를 만들기 위해 널리/다양하게 활용되는 관용구이다.

- nullable 안전 호출
    
    ```kotlin
    class Person(val name: String)
    var person: Person? = null
    
    fun printName() {
    	person?.let {
    		print(it.name)
    	}
    ```
    
- 연산을 아규먼트 처리 후로 이동시킬 때
    
    ```kotlin
    students
    	.filter { it.result >= 50 }
    	.joinToString(separator = "\n") {
    		"${it.name} ${it.surname}, ${it.result}"
    	}
    	.let(::print) // print 를 뒤로 이동시킨 경우
    ```
    
- 데코레이터를 사용해서 객체를 wrap 할 때
    
    ```kotlin
    var obj = FileInputStream("/file.gz")
    	.let(::BufferedInputStream)
    	.let(::ZipInputStream)
    	.let(::ObjectInputStream)
    	.readObject() as SomeObject
    ```
<br> 

**결론**

- 관용구를 이해하는데 비용이 발생하더라도, 그만한 가치가 있다면 사용해도 좋다.
- 문제가 되는 경우는 그만한 가치가 없을 때(= 이유없이 복잡성을 추가하는 경우) 이다.
  
<br> 

### 컨벤션

사람에 따라 가독성에 대한 관점이 다르다. 

- 함수 이름을 어떻게 지어야 하는지
- 어떤 것이 명시적이어야 하는지
- 어떤 것이 암묵적이어야 하는지
- 어떤 관용구를 사용해야 하는지

와 관련된 규칙들을 이해하고 기억해야 한다.

(이후에 나오는 내용들이 이것들을 설명함)

## (아이템12) 연산자 오버로드를 할 때는 의미에 맞게 사용하라

연산자 오버로딩은 굉장히 강력한 기능이지만, 그만큼 위험할 수 있다.

다음은 팩토리얼을 구하는 함수다.

```kotlin
fun Int.factorial(): Int = (1..this).product()

fun Iterable<Int>.product(): Int = 
		fold(1) { acc, i -> acc * i }
```
<br>
그리고 연산자 오버로딩을 이용하면 실제 팩토리얼과 비슷하게 ! 기호를 이용해서 표현이 가능하다.

```kotlin
operator fun Int.not() = factorial()

print(10 * !6) // 10 * 6!
```

하지만 함수의 이름이 not 이므로 논리연산에 맞게 사용해야지, 팩토리얼 연산에 사용하면 안된다.

- 혼란스럽고 오해의 소지가 있다.
- **관례에 어긋난다.**

<br>

### 분명하지 않은 경우

관례를 충족하는지 어긋나는지 확실하지 않은 경우가 문제이다.

예를들어 함수를 곱한다는 것 (* 연산자)의 의미를 두가지로 해석할 수 있다.

1. 새로운 함수(`() → Unit`)를 만들어 낸다.
2. 같은 함수를 세 번 호출한다.

<br>

의미가 명확하지 않다면, infix 를 활용한 확장 함수를 사용한다.

```kotlin
infix fun Int.timesRepeated(operation: ()->Unit) = {
		repeat(this) { operation() }
}

val tripledHello = 3 timesRepeated { print("Hello") } // 2항 연산자 처럼 사용
tripleHello() // 출력 : HelloHelloHello
```

<br>

또는 톱레벨 함수를 사용한다.

```kotlin
repeat(3) { print("Hello") } // 출력: HelloHelloHello
```
<br>

### 규칙을 무시해도 되는 경우

도메인 특화 언어(Domain Specific Language, DSL) 를 설계할 때는 연산자 오버로딩 규칙을 무시해도 된다.

- 해당 도메인을 위해 설계된 DSL 이기 때문

```kotlin
body {
	div {
		+"Some Text" // <- String.unaryPlus 가 문자열 앞에 사용되었다.
	}
}
```
